# Структурные (Creational)

## [Decorator](01-decorator.js)

### Назначение:

Динамически добавляет объекту новые обязанности. Является гибкой альтернативой порождению подклассов с целью расширения функциональности.
Позволяет оборачивать общект в класс декоратора и тем самым расширять его возможности
Вместо создания большого кол-ва подклассов от базового класса, мы можем применять декораторы для модификации

### Когда следует использовать декораторы?

- Когда надо динамически добавлять к объекту новые функциональные возможности. При этом данные возможности могут быть сняты с объекта
- Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей и для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. Еще больше она может разрастись, если нам необходимо создать классы, реализующие все возможные сочетания добавляемых функциональностей.

## [Facade](02-facade.js)

### Назначение:

предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.
Шаблон Фасад объединяет группу объектов в рамках одного специализированного интерфейса и переадресует вызовы его методов к этим объектам.

### Когда использовать фасад?

- Когда имеется сложная система, и необходимо упростить с ней работу. Фасад позволит определить одну точку взаимодействия между клиентом и системой.
- Когда надо уменьшить количество зависимостей между клиентом и сложной системой. Фасадные объекты позволяют отделить, изолировать компоненты системы от клиента и развивать и работать с ними независимо.
- Когда нужно определить подсистемы компонентов в сложной системе. Создание фасадов для компонентов каждой отдельной подсистемы позволит упростить взаимодействие между ними и повысить их независимость друг от друга.

## [Proxy](03-proxy.js)

### Назначение:

Изменение требований и эволюция системы могут вызвать необходимость внесения серьезных архитектурных изменений.
Если на ранних этапах некая операция выполнялась на стороне клиента или же приложение состояло из одного процесса,
то со временем исполнение операции может быть перенесено на сервер, а приложение разбито на несколько процессов.
В результате возникает задача взаимодействия с удаленным процессом, реализация которой должна быть максимально похожей на локальное взаимодействие.
Именно для таких целей предназначен паттерн «Заместитель».
**Proxy (заместитель)** — является суррогатом другого объекта и контролирует доступ к нему.

### Когда использовать Proxy?

«Заместитель» является одним из немногих паттернов проектирования, который с течением времени претерпел довольно серьезные изменения.
В классическом труде «банды четырех» описаны три основных сценария использования паттерна «Заместитель».

- Удаленный заместитель (remote proxies) — отвечает за кодирование запроса и его аргументов для работы с компонентом в другом адресном пространстве.
- Виртуальный заместитель (virtual proxies) — может кэшировать дополнительную информацию о реальном компоненте, чтобы отложить его создание.
- Защищающий заместитель (protection proxies) — проверяет, имеет ли вызывающий объект необходимые для выполнения запроса права.

## [Adapter](04-adapter.js)

### Назначение:

Преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты. Адаптер делает возможной совместную работу классов с несовместимыми интерфейсами.

### Когда следует использовать Адаптер?

- Когда необходимо использовать имеющийся класс, но его интерфейс не соответствует потребностям бизнесс логики.
- Когда надо использовать уже существующий класс совместно с другими классами, интерфейсы которых не совместимы.

## [Composite](05-composite.js)

### Назначение:

Позволяет скомпоновать множество объектов в древовидно структуру и работать с ней как с единым объектом.
Сам объект мало что знает про вложенные структуры, он просто реализует те же методы что и вложенные компоненты.
Вместо вызова метода он передает его во все вложенные структуры, а они в свои.
Компоненты - листья, Связи - ветки.

### Когда использовать Composite?

- Когда объекты должны быть реализованы в виде иерархической древовидной структуры
- Когда клиенты единообразно должны управлять как целыми объектами, так и их составными частями. То есть целое и его части должны реализовать один и тот же интерфейс

## [Brdige](06-brdige.js)

### Назначение:

Мост (Bridge) - структурный шаблон проектирования, который позволяет отделить абстракцию от реализации таким образом, чтобы и абстракцию, и реализацию можно было изменять независимо друг от друга.

Шаблон Мост предполагает, что основной код, необходимый для функционирования объекта, переносится в реализацию. Всё остальное, включая взаимодействие с клиентом, содержится в абстракции. Её методы, при необходимости, могут быть изменены или дополнены. Кроме того, она содержит экземпляр реализации и использует его для обработки поступающих от клиентов запросов. Под обработкой подразумевается как прямая переадресация запроса, так и вызов группы методов реализации для получения результата.

### Когда использовать паттерн мост?

- Когда надо избежать постоянной привязки абстракции к реализации
- Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. То есть изменения в абстракции не должно привести к изменениям в реализации

## [Lightweight](07-lightweight.js)

### Назначение:

Паттерн Приспособленец (Flyweight) - шаблон проектирования, который позволяет использовать разделяемые объекты сразу в нескольких контекстах. Данный паттерн используется преимущественно для оптимизации работы с памятью.

Приспособленец это экземпляр объекта, который выдает себя за группу самостоятельных экземпляров.

### Когда использовать Flyweight?

- в приложении используется большое число очень схожих экземпляров заданного класса;
- (и) часть состояния объекта является контекстной и может быть легко вынесена во внешние структуры;
- (и) после вынесения части состояния, все экземпляры становятся одинаковыми и это дает возможность заменить их одним;
- (и) приложение не проверяет идентичность объектов, т.к. в этом случае все якобы самостоятельные экземпляры являются одним объектом.
